import "dart:async" as gB;import "dart:collection" as lB;import "dart:json" as eD;import "dart:html" as n;import "dart:isolate" as yD;class fD{static const  gD="Chrome";static const  hD="Firefox";static const  iD="Internet Explorer";static const  jD="Safari";final  PD;final  minimumVersion;const fD(this.PD,[this.minimumVersion]);}class kD{final  name;const kD(this.name);} KC(){} LC(){var EE=n.document.body;var FE;var GE=new nC(EE);FE=EE.nodes[3].nodes[1];GE.VB(new lD()..host=FE);GE.fB();GE.insert();}main(){BC=true;KC();LC();}class lD extends FC with u{var HE;static final MC=new n.DocumentFragment.html('''
      <div class="entry">
        <label>First name?</label>
        <input type="text">
      </div>
      <div class="entry">
        <label>Favorite quote?</label>
        <textarea></textarea>
      </div> 
      <div class="entry">
        <label>Favorite color?</label>
        <input type="color">
      </div>
      <div class="entry">
        <label>Birthday?</label>
        <input type="date">
      </div>
      <div class="entry">
        <label>Favorite volume?</label>
        <input type="range" min="0" max="11">  
      </div>
      <div class="entry">
        <label>Cat or dog?</label>
        <input name="catOrDog" type="radio" value="cat">Cat
        <input name="catOrDog" type="radio" value="dog">Dog
        <input name="catOrDog" type="radio" value="iguana">Iguana
      </div>
      <div>
        <label>Favorite type of music?</label>
        <select>
          <option>Classical</option>
          <option>Country</option>
          <option>Rock</option>
          <option>Silence</option>
        </select>
      </div>
      <div class="entry">
        <label for="zombies">Check for zombies. </label>
        <input type="checkbox" id="zombies">
      </div>
      <div class="entry">
        <label>Favorite things?</label>
        <input type="checkbox" id="kittens">
          <label for="kittens" class="andrews">Kittens</label>
        <input type="checkbox" id="raindrops">
          <label for="raindrops" class="andrews">Raindrops</label>
        <input type="checkbox" id="mittens">
          <label for="mittens" class="andrews">Mittens</label>
        <input type="checkbox" id="kettles">
          <label for="kettles" class="andrews">Kettles</label>
      </div>

      <div class="submitarea">
        <input type="submit" value="Submit">
        <input type="reset" value="Clear"> <br>    
        <textarea disabled="" class="responsetext"></textarea>
      </div>
      
      <script type="application/dart" src="xslambookform.dart">
      </script>
    ''');var IE,JE,KE,LE,ME,NE,OE,PE,QE,RE,SE,TE,UE,VE;var WE;var XE;var YE,ZE; TD(){var aE=createShadowRoot("x-slambook-form");bD("x-slambook-form",new tB({"x-slambook-form":"[is=\"x-slambook-form\"]"}));HE=UD("x-slambook-form");XE=new nC(aE);aE.nodes.add(MC.clone(true));IE=aE.nodes[1].nodes[3];XE.listen(IE.onInput,(h){l['firstName']=IE.value;});XE.AB(()=>l['firstName'],(g){if(IE.value!=g)IE.value=g;},false,false);ZE=aE.nodes[3].nodes[3];XE.listen(ZE.onInput,(h){l['favoriteQuote']=ZE.value;});XE.AB(()=>l['favoriteQuote'],(g){if(ZE.value!=g)ZE.value=g;},false,false);QE=aE.nodes[5].nodes[3];XE.listen(QE.onInput,(h){l['favoriteColor']=QE.value;});XE.AB(()=>l['favoriteColor'],(g){if(QE.value!=g)QE.value=g;},false,false);RE=aE.nodes[7].nodes[3];XE.listen(RE.onInput,(h){l['birthday']=RE.value;});XE.AB(()=>l['birthday'],(g){if(RE.value!=g)RE.value=g;},false,false);SE=aE.nodes[9].nodes[3];XE.listen(SE.onInput,(h){l['volume']=SE.value;});XE.AB(()=>l['volume'],(g){if(SE.value!=g)SE.value=g;},false,false);TE=aE.nodes[11].nodes[3];XE.listen(TE.onChange,(h){l['catOrDog']='cat';});XE.AB(()=>l['catOrDog']=='cat',(g){if(TE.checked!=g)TE.checked=g;},false,false);UE=aE.nodes[11].nodes[5];XE.listen(UE.onChange,(h){l['catOrDog']='dog';});XE.AB(()=>l['catOrDog']=='dog',(g){if(UE.checked!=g)UE.checked=g;},false,false);VE=aE.nodes[11].nodes[7];XE.listen(VE.onChange,(h){l['catOrDog']='iguana';});XE.AB(()=>l['catOrDog']=='iguana',(g){if(VE.checked!=g)VE.checked=g;},false,false);WE=aE.nodes[13].nodes[3];XE.listen(WE.onChange,(h){l['music']=WE.selectedIndex;});XE.AB(()=>l['music'],(g){if(WE.selectedIndex!=g)WE.selectedIndex=g;},false,false);JE=aE.nodes[15].nodes[3];XE.listen(JE.onChange,(h){l['zombies']=JE.checked;});XE.AB(()=>l['zombies'],(g){if(JE.checked!=g)JE.checked=g;},false,false);KE=aE.nodes[17].nodes[3];XE.listen(KE.onChange,(h){FB['kittens']=KE.checked;});XE.AB(()=>FB['kittens'],(g){if(KE.checked!=g)KE.checked=g;},false,false);LE=aE.nodes[17].nodes[7];XE.listen(LE.onChange,(h){FB['raindrops']=LE.checked;});XE.AB(()=>FB['raindrops'],(g){if(LE.checked!=g)LE.checked=g;},false,false);ME=aE.nodes[17].nodes[11];XE.listen(ME.onChange,(h){FB['mittens']=ME.checked;});XE.AB(()=>FB['mittens'],(g){if(ME.checked!=g)ME.checked=g;},false,false);NE=aE.nodes[17].nodes[15];XE.listen(NE.onChange,(h){FB['kettles']=NE.checked;});XE.AB(()=>FB['kettles'],(g){if(NE.checked!=g)NE.checked=g;},false,false);OE=aE.nodes[19].nodes[1];XE.listen(OE.onClick,(h){dD(h);});PE=aE.nodes[19].nodes[3];XE.listen(PE.onClick,(h){aD(h);});YE=aE.nodes[19].nodes[7];XE.listen(YE.onInput,(h){WB=YE.value;});XE.AB(()=>WB,(g){if(YE.value!=g)YE.value=g;},false,false);XE.fB();} WD(){XE.insert();} ZD(){XE.remove();XE=IE=ZE=QE=RE=SE=TE=UE=VE=WE=JE=KE=LE=ME=NE=OE=PE=YE=null;}var bE=xB({'kittens':true,'raindrops':false,'mittens':true,'kettles':false}); get FB{if(s){w(this,k.q,'favoriteThings');}return bE;}var dE=xB({'firstName':'mem','favoriteQuote':'Enjoy all your meals.','favoriteColor':'#4169E1','birthday':'1963-08-30','volume':'11','catOrDog':'dog','music':2,'zombies':true}); get l{if(s){w(this,k.q,'theData');}return dE;}var eE=''; get WB{if(s){w(this,k.q,'serverResponse');}return eE;}set WB( g){if(IB(this)){o(this,k.q,'serverResponse',eE,g);}eE=g;}var request; dD( g){g.preventDefault();request=new n.HttpRequest();request.onReadyStateChange.listen(onData);var h='http://127.0.0.1:4040';request.open('POST',h);request.send(cD());} onData(fE){if(request.readyState==n.HttpRequest.DONE&&request.status==200){WB='Server Sez: '+request.responseText;}else if(request.readyState==n.HttpRequest.DONE&&request.status==0){WB='No server';}} aD( g){g.preventDefault();FB['kittens']=false;FB['raindrops']=false;FB['mittens']=false;FB['kettles']=false;l['firstName']='';l['favoriteQuote']='';l['favoriteColor']='#FFFFFF';l['birthday']='2013-01-01';l['volume']='0';l['catOrDog']='cat';l['music']=0;l['zombies']=false;WB='Data cleared.';} cD(){l['favoriteThings']=FB;return eD.stringify(l);}}class NC<JB> extends jC with u implements List<JB>{final  gE;NC([ g]):gE=g!=null?new List<JB>(g):<JB>[] ;factory NC.zD( g)=>new NC<JB>()..addAll(g); get length{if(s)w(this,k.q,'length');return gE.length;}set length( h){var i=gE.length;if(i==h)return;if(IB(this)){if(h<i){for(int g=i-1;g>=h;g-- ){o(this,k.LB,g,gE[g],null);}o(this,k.q,'length',i,h);}else{o(this,k.q,'length',i,h);for(int g=i;g<h;g++ ){o(this,k.NB,g,null,null);}}}gE.length=h;} operator[]( g){if(s)w(this,k.GB,g);return gE[g];}operator[]=( g, h){var i=gE[g];if(IB(this)){o(this,k.GB,g,i,h);}gE[g]=h;} sublist( h,[ g])=>new NC<JB>.zD(super.sublist(h,g)); add( h){var g=gE.length;if(IB(this)){o(this,k.q,'length',g,g+1);o(this,k.NB,g,null,h);}gE.add(h);} removeRange( h, g){if(g==0)return;AC.hC(this,h,g);if(IB(this)){for(int i=h;i<g;i++ ){o(this,k.LB,i,this[i],null);}}AC.gC(this,h+g,this,h,this.length-g-h);this.length=this.length-g;} toString(){if(s){for(int g=0;g<length;g++ ){w(this,k.GB,g);}}return gE.toString();}}typedef  YB<v,t>();class QB<v,t> extends u implements Map<v,t>{final  hE;var iE;var jE;QB({ createMap}):hE=createMap!=null?createMap():new Map<v,t>(){iE=new OC<v,t>(this);jE=new PC<v,t>(this);}factory QB.AE( i,{ createMap}){var g=new QB<v,t>(createMap:createMap);i.forEach(( h, j){g[h]=j;});return g;} get keys=>iE; get values=>jE; get length{if(s)w(this,k.q,'length');return hE.length;} get isEmpty=>length==0; get isNotEmpty=>length!=0; kE( g)=>w(this,k.GB,g); lE(){w(this,k.q,'length');hE.keys.forEach(kE);} containsKey( g){if(s)kE(g);return hE.containsKey(g);} operator[]( g){if(s)kE(g);return hE[g];} operator[]=( h, g){var j=hE.length;var i=hE[h];hE[h]=g;if(IB(this)){if(j!=hE.length){o(this,k.q,'length',j,hE.length);o(this,k.NB,h,i,g);}else if(i!=g){o(this,k.GB,h,i,g);}}} putIfAbsent( g, j()){if(s)kE(g);var h=hE.length;var i=hE.putIfAbsent(g,j);if(IB(this)&&h!=hE.length){o(this,k.q,'length',h,hE.length);o(this,k.NB,g,null,i);}return i;} remove( g){if(s)kE(g);var h=hE.length;var i=hE.remove(g);if(IB(this)&&h!=hE.length){o(this,k.LB,g,i,null);o(this,k.q,'length',h,hE.length);}return i;} clear(){var g=hE.length;if(IB(this)&&g>0){hE.forEach((i,h){o(this,k.LB,i,h,null);});o(this,k.q,'length',g,0);}hE.clear();} forEach( g( key, value)){if(s)lE();hE.forEach(g);} toString()=>lB.Maps.mapToString(this);}class OC<v,t> extends lB.IterableBase<v>{final  hE;OC(this.hE); get iterator=>new mD<v,t>(hE);}class mD<v,t> implements Iterator<v>{final  hE;final  iE;var mE=false;mD( g):hE=g,iE=g.hE.keys.iterator; moveNext(){if(s)w(hE,k.q,'length');return mE=iE.moveNext();} get current{var g=iE.current;if(s&&mE)hE.kE(g);return g;}}class PC<v,t> extends lB.IterableBase<t>{final  hE;PC(this.hE); get iterator=>new nD<v,t>(hE);}class nD<v,t> implements Iterator<t>{final  hE;final  iE;final  jE;var mE;nD( g):hE=g,iE=g.hE.keys.iterator,jE=g.hE.values.iterator; moveNext(){if(s)w(hE,k.q,'length');var h=iE.moveNext();var g=jE.moveNext();if(h!=g){throw new StateError('keys and values should be the same length');}return mE=g;} get current{if(s&&mE)hE.kE(iE.current);return jE.current;}}typedef  KB( e);typedef  QC( changes);typedef  RB();typedef  RC();class hB{final oldValue;final newValue;final  changes;hB(this.oldValue,this.newValue,[this.changes]); operator==(g){return g is hB&&oldValue==g.oldValue&&newValue==g.newValue&&changes==g.changes;} get hashCode=>dC(oldValue,newValue,changes); toString(){if(changes!=null)return '#<ChangeNotification to ${newValue}: ${changes}>';return '#<ChangeNotification from ${oldValue} to ${newValue}>';}}class k{static const q=1;static const GB=2;static const NB=GB|4;static const LB=GB|8;final  type;final key;final oldValue;final newValue;k(this.type,this.key,this.oldValue,this.newValue); operator==(g){return g is k&&type==g.type&&key==g.key&&oldValue==g.oldValue&&newValue==g.newValue;} get hashCode=>eC(type,key,oldValue,newValue); toString(){var g;switch (type){case q:g='field';break;case GB:g='index';break;case NB:g='insert';break;case LB:g='remove';break;}return '#<ChangeRecord ${g} ${key} from ${oldValue} to ${newValue}>';}} SC(g, i,[ m]){if(g is u){var h=g;return mB(h,(p){i(new hB(h,h,p));});}var j=new iB(g,i,m);if(!j.nE()){return UC;}return j.oE;} mB( g, i){if(g.UB==null)g.UB=new nB();var h=g.UB.add(i);return h.remove;}xB(g){if(g is Map){var h=null;if(g is lB.SplayTreeMap){h=()=>new lB.SplayTreeMap();}else if(g is lB.LinkedHashMap){h=()=>new lB.LinkedHashMap();}return new QB.AE(g,createMap:h);}if(g is Set)return new zB.BE(g);if(g is Iterable)return new NC.zD(g);return g;}class u{var UB;var TB;final  hashCode= ++u.TC;static var TC=0;} IB( g)=>g.UB!=null&&g.UB.head!=null; get s=>SB!=null; w( g, h,i)=>SB.pE(g,h,i); o( g, j,m, h, i){if((j&(k.NB|k.LB))==0){if(h==i)return;}if(OB==null){OB=[] ;fC(VC);}if(g.TB==null){g.TB=[] ;OB.add(g);}g.TB.add(new k(j,m,h,i));} UC(){}var SB;var yB=100;var OB;var PB; VC(){var p=0;while (OB!=null||PB!=null){var j=OB;OB=null;var i=PB;PB=null;if(p++ ==yB){WC(j,i);return;}if(j!=null){for(var h in j){var MB=h.TB;h.TB=null;for(var g=h.UB.head;g!=null;g=g.next){var m=g.value;try {m(MB);}catch (XB,BB){ZB(XB,BB,m,'from ${h}');}}}}if(i!=null){i.forEach((xD,wB){wB.qE();});}}} WC( m, j){var g=[] ;if(m!=null){for(var i in m){var MB=i.TB;g.add('${i} ${MB}');}}if(j!=null){for(var p in j.values){var h=p.qE();if(h!=null)g.add('${p} ${h}');}}OB=null;PB=null;var BB='exceeded notifiction limit of ${yB}, possible ' 'circular reference in observer callbacks: ${g.take(10).join(", ")}';ZC(BB);}class iB{static var XC=0;final  rE= ++iB.XC;final  sE;final  tE;final  uE;final  vE=new Map();final  wE=[] ;var xE=false;var yE;iB(this.sE,this.tE,this.uE); toString()=>uE!=null?'<observer ${rE}: ${uE}>':'<observer ${rE}>'; nE(){var h=SB;SB=this;try {yE=sE();if(yE is Iterable&&yE is !List&&yE is !u){yE=(yE as Iterable).toList();}}catch (g,i){ZB(g,i,sE,'from ${this}');yE=null;}vE.forEach(zE);vE.clear();assert(SB==this);SB=h;AF();return wE.length>0;} BF( i){try {tE(i);}catch (g,h){ZB(g,h,tE,'from ${this}');}} AF(){var g=yE;if(g is !u)return;wE.add(mB(g,(h){BF(new hB(g,g,h));}));} pE( p, BB,g){var i=vE.putIfAbsent(p,()=>new Map());try {var h=i[g];if(h==null)h=0;i[g]=h|BB;}catch (j,m){ZB(j,m,g,'hashCode or operator == from ${this}');}} zE( i, j){wE.add(mB(i,(m){if(xE)return;for(var g in m){var h=j[g.key];if(h!=null&&(h&g.type)!=0){xE=true;if(PB==null){PB=new lB.SplayTreeMap();}PB[rE]=this;return;}}}));} oE(){for(var g in wE){g();}xE=false;} qE(){if(!xE)return null;var g=yE;oE();nE();try {if(g==yE)return null;}catch (i,j){ZB(i,j,g,'operator == from ${this}');return null;}var h=new hB(g,yE);BF(h);return h;}}typedef  YC( message);var ZC=(g)=>print(g);typedef  aC(error,stackTrace,obj, message);var ZB=bC; bC(i,g,h, j){print('web_ui.observe: unhandled error calling ${h} ${j}.\n' 'error:\n${i}\n\nstack trace:\n${g}');}class zB<HB> extends iC with u implements Set<HB>{final  CF;final  DF;zB({ createMap}):CF=createMap!=null?createMap():new Map<HB,Object>(),DF=createMap;factory zB.BE( g,{ createMap}){return new zB<HB>(createMap:createMap)..addAll(g);} contains( g){if(s)w(this,k.GB,g);return CF.containsKey(g);} add( g){var h=CF.length;CF[g]=const Object();if(h!=CF.length){o(this,k.q,'length',h,CF.length);o(this,k.NB,g,null,g);}} remove( g){if(s)w(this,k.GB,g);var h=CF.length;CF.remove(g);if(h!=CF.length){if(IB(this)){o(this,k.LB,g,g,null);o(this,k.q,'length',h,CF.length);}return true;}return false;} clear(){if(IB(this)){for(var g in CF.keys){o(this,k.LB,g,g,null);}o(this,k.q,'length',CF.length,0);}CF.clear();} get length{if(s)w(this,k.q,'length');return CF.length;} get isEmpty=>length==0; get iterator=>new oD<HB>(this); addAll( g)=>g.forEach(add); toString(){if(s){for(HB g in CF.keys){w(this,k.GB,g);}}return CF.keys.toSet().toString();}}class oD<HB> implements Iterator<HB>{final  EF;final  FF;var GF=false;oD( g):EF=g,FF=g.CF.keys.iterator; moveNext(){EF.length;return GF=FF.moveNext();} get current{var g=FF.current;if(s&&GF)w(EF,k.GB,g);return g;}}class cC{cC();}class DB<EB>{var HF;var IF;var JF;var KF;DB.CE( g,this.JF):KF=g{if(JF!=null)JF.LF++ ;} get next=>IF; get value=>KF;set value( g)=>KF=g; MF( g, h){IF=h;HF=g;if(g!=null)g.IF=this;if(h!=null)h.HF=this;return this;} append( g)=>new DB<EB>.CE(g,JF).MF(this,IF); remove(){if(JF==null)return;JF.LF-- ;if(HF!=null){HF.IF=IF;}else{JF.NF=IF;}if(IF!=null){IF.HF=HF;}else{JF.OF=HF;}IF=null;HF=null;JF=null;}}class nB<EB> extends lB.IterableBase<EB>{var NF;var OF; get length=>LF;var LF=0;nB(){} get head=>NF; add( h){var g=new DB<EB>.CE(h,this);if(OF==null)return NF=OF=g;return OF=g.MF(OF,null);} addLast( g)=>add(g); addAll( g)=>g.forEach(add); get iterator=>new pD<EB>(this);}class pD<EB> implements Iterator<EB>{var PF;var JF;var QF;var RF=-1;pD(this.JF){PF=new List<DB>(JF.length);var h=0;var g=JF.head;while (g!=null){PF[h++ ]=g;g=g.next;}} get current=>QF; moveNext(){do{RF++ ;}while(RF<PF.length&&PF[RF].JF!=JF);if(RF<PF.length){QF=PF[RF].value;return true;}else{QF=null;return false;}}}aB(h,g)=>h.hashCode*31+g.hashCode;dC(h,g,i)=>aB(aB(h,g),i);eC(g,i,h,j)=>aB(aB(g,i),aB(h,j)); fC( h()){var g=new yD.ReceivePort();g.receive((i,j){g.close();h();});g.toSendPort().send(null);}class AC{static  gC( p, g, BB, i, m){if(g==null)g=0;if(i==null)i=0;if(g<i){for(int h=g+m-1,j=i+m-1;h>=g;h-- ,j-- ){BB[j]=p[h];}}else{for(int h=g,j=i;h<g+m;h++ ,j++ ){BB[j]=p[h];}}}static  hC( j, h, g){if(g<0){throw new ArgumentError("negative length ${g}");}if(h<0){var i="${h} must be greater than or equal to 0";throw new RangeError(i);}if(h+g>j.length){var i="${h} + ${g} must be in the range [0..${j.length})";throw new RangeError(i);}}}abstract class iC extends lB.IterableBase<dynamic>{}abstract class jC extends lB.ListMixin<dynamic>{} kC(g){if(g is cC)return g.toString();g=g.toString();return mC(g)?g:'#';}const lC=const["http","https","ftp","mailto"]; mC( h){var g=Uri.parse(h).scheme;if(g=='')return true;return lC.contains(g.toLowerCase())||"MAILTO"==g.toUpperCase();}abstract class bB{ fB(){} insert(); remove();}class qD extends bB{final  HC;var SF;final  listener;qD(this.HC,this.listener); insert(){SF=HC.listen(listener);} remove(){SF.cancel();SF=null;}}class rD extends bB{final  JC;final  vB;final  IC;final  isFinal;var kB;rD(this.vB,this.JC,this.IC,this.isFinal); TF(g){JC(IC?kC(g):g);} insert(){if(isFinal){TF(vB());}else if(kB!=null){throw new StateError('data binding already attached.');}else{kB=qC(vB,(g)=>TF(g.newValue),'dom-property-binding');}} remove(){if(!isFinal){kB();kB=null;}}}class sD extends bB{final VB;sD(this.VB); fB(){VB..TD()..SD()..RD();} insert(){VB..VD()..WD();} remove(){VB..ZD()..YD();}}class nC extends bB{final  XD;final  children=[] ;final  nodes=[] ;nC(this.XD); listen( i, h){children.add(new qD(i,(g){h(g);rC();}));} AB(g,j,h,[i=false]){children.add(new rD(g,j,i,h));} VB( g){children.add(new sD(g));} add( g)=>nodes.add(g); addAll( g)=>nodes.addAll(g); fB(){for(var g=0,h=children.length;g<h;g++ ){children[g].fB();}} insert(){for(var g=0,h=children.length;g<h;g++ ){children[g].insert();}} remove(){for(var g=children.length-1;g>=0;g-- ){children[g].remove();}children.clear();}}var BC=false; oC(g, p,[ m]){if(BC)return SC(g,p);if(p==null)return (){};if(cB==null)cB=new nB<dB>();var i;var h=CB.vC;if(g is EC){i=(g as EC).UF;}else if(g is Function){i=g;try {var j=g();if(j is List){h=CB.eB;}else if(j is Iterable){h=CB.eB;i=()=>g().toList();}else if((j is lB.LinkedHashMap)||(j is lB.SplayTreeMap)){h=CB.qB;}else if(j is Map){h=CB.pB;}}catch (MB,wB){print('error: evaluating ${m!=null?m:"<unnamed>"} ' 'watcher threw error (${MB}, ${wB})');}}else if(g is List){i=()=>g;h=CB.eB;}else if(g is Iterable){i=()=>g.toList();h=CB.eB;}else if((g is lB.LinkedHashMap)||(g is lB.SplayTreeMap)){i=()=>g;h=CB.qB;}else if(g is Map){i=()=>g;h=CB.pB;}var BB=pC(h,i,p,m);var XB=cB.add(BB);return XB.remove;} pC( j, g, i, h){switch (j){case CB.eB:return new tD(g,i,h);case CB.qB:return new vD(g,i,h);case CB.pB:return new uD(g,i,h);default:return new dB(g,i,h);}} qC(h,i,[j]){var m=oC(h,i,j);var g=h;if(g is Function){g=g();}if(g is Iterable&&g is !List){g=g.toList();}i(new hB(null,g));return m;}var cB;class dB{final  uB;final  UF;final  VF;var WF;dB(this.UF,this.VF,this.uB){WF=UF();} toString()=>uB==null?'<unnamed>':uB; QD(){var g=XF();if(YF(g)){var h=WF;ZF(g);VF(new hB(h,g));return true;}return false;} YF(g)=>WF!=g; ZF(g){WF=g;}XF(){try {return UF();}catch (g,h){print('error: evaluating ${this} watcher threw an exception (${g}, ${h})');}return WF;}}final  CC=10; rC(){if(cB==null)return;var g;var h=0;do{g=false;for(var i in cB){if(i.QD()){g=true;}}}while(g&& ++h<CC);if(h==CC){print('Possible loop in watchers propagation, stopped dispatch.');}}typedef  DC<sC>();typedef  tC<sC>( value);class EC<sC>{EC();}class tD<sC> extends dB{tD(g, i, h):super(g,i,h){ZF(XF());} YF( g){return oB(WF,g);} ZF(g){WF=new List<sC>.from(g);}}class uD<jB,uC> extends dB{uD(g, i, h):super(g,i,h){ZF(XF());} YF( g){var i=WF.keys;if(i.length!=g.keys.length)return true;var j=i.iterator;while (j.moveNext()){var h=j.current;if(!g.containsKey(h))return true;if(WF[h]!=g[h])return true;}return false;} ZF(g){WF=new Map<jB,uC>.from(g);}}class vD<jB,uC> extends dB{vD(g, i, h):super(g,i,h){ZF(XF());} YF( g){return oB(g.keys,WF.keys)||oB(g.values,WF.values);} ZF(g){WF=new lB.LinkedHashMap.from(g);}} oB( i, j){var h=i.iterator;var g=j.iterator;while (h.moveNext()){if(!g.moveNext())return true;if(h.current!=g.current)return true;}return g.moveNext();}class CB{final aF;const CB.DE(this.aF);toString()=>'Enum.${aF}';static const eB=const CB.DE('LIST');static const pB=const CB.DE('HASH_MAP');static const qB=const CB.DE('ORDERED_MAP');static const vC=const CB.DE('OTHER');}abstract class FC implements n.Element{var bF;var cF;var dF={};var eF=new tB({}); UD( g)=>eF; bD( h,var g){eF=g;} get host{if(bF==null)throw new StateError('host element has not been set.');return bF;}set host( g){if(g==null){throw new ArgumentError('host must not be null.');}var h=g.xtag;if(h!=null&&h!=g){throw new ArgumentError('host must not have its xtag property set.');}if(bF!=null){throw new StateError('host can only be set once.');}g.xtag=this;bF=g;}createShadowRoot([ g]){var h=fF();if(g!=null){dF[g]=h;}return h;}fF(){if(GC){return host.createShadowRoot();}if(cF==null)cF=[] ;cF.add(new n.DivElement());return cF.last;} SD(){} VD(){} YD(){} RD(){if(GC)return;if(cF.length==0){throw new StateError('Distribution algorithm requires at least one shadow' ' root and can only be run once.');}var j=cF;var g=j.removeLast();var BB=g;var p=new List.from(nodes);var m=[] ;var MB=[] ;while (true){p=gF(g,p);var h=g.query('shadow');if(h!=null){if(j.length>0){g=j.removeLast();m.add(h);MB.add(g);}else{sB(h,p);break;}}else{break;}}for(int i=0;i<m.length;i++ ){var h=m[i];var g=MB[i];sB(h,g.nodes);}nodes.clear();nodes.addAll(BB.nodes);for(var XB in dF.keys){if(dF[XB]==BB){dF[XB]=this;break;}}} gF( BB, j){for(var g in BB.queryAll('content')){if(!xC(g))continue;var i=g.attributes['select'];if(i==null||i=='')i='*';var h=[] ;var p=[] ;for(var m in j){(wC(m,i)?h:p).add(m);}if(h.length==0){h=g.nodes;}sB(g,h);j=p;}return j;}static  wC( h, g){if(h is !n.Element)return g=='*';return (h as n.Element).matches(g);}static  rB( g)=>g.tagName=='CONTENT'||g.tagName=='SHADOW';static  xC( g){assert(rB(g));for(g=g.parent;g!=null;g=g.parent){if(rB(g))return false;}return true;}static  sB( g, h){assert(rB(g));g.parent.insertAllBefore(h,g);g.remove();} get nodes=>host.nodes; replaceWith( g){host.replaceWith(g);} remove()=>host.remove();set text( g){host.text=g;} contains( g)=>host.contains(g); insertBefore( g, h)=>host.insertBefore(g,h); insertAllBefore( g, h)=>host.insertAllBefore(g,h); get attributes=>host.attributes; get children=>host.children; clone( g)=>host.clone(g); get parent=>host.parent; get parentNode=>host.parentNode; get nodeValue=>host.nodeValue; get id=>host.id;set id( g){host.id=g;} set innerHtml( g){host.innerHtml=g;} get tagName=>host.tagName; matches( g)=>host.matches(g); query( g)=>host.query(g); queryAll( g)=>host.queryAll(g); get CD=>host.CD; get DD=>host.DD; get GD=>host.GD; ED( g)=>host.ED(g); FD( g)=>host.FD(g); JD( g)=>host.JD(g); KD( g)=>host.KD(g); OD( h, g)=>host.OD(h,g);get AD=>host.AD; get BD=>host.BD; get localName=>host.localName; get HD=>host.HD; get ID=>host.ID; zC( i, g,[ h]){host.zC(i,g,h);} LD( g)=>host.LD(g); MD( i, g,[ h]){host.MD(i,g,h);} ND( g, h)=>host.ND(g,h);get xtag=>host.xtag;set xtag(g){host.xtag=g;} append( g)=>host.append(g); get onChange=>host.onChange; get onClick=>host.onClick; get onInput=>host.onInput;}class tB{final  hF;tB(this.hF); operator[]( g)=>hF[g];}var yC=false; get GC=>yC&&n.ShadowRoot.supported;//@ sourceMappingURL=slambook.html_bootstrap.dart.map
